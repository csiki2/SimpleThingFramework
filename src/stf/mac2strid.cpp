/*
  SimpleThingFramework

  Copyright 2021 Andras Csikvari

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/

#include <stf/mac2strid.h>

namespace stf {

struct macMap {
  const char* name;
  const uint8_t* mac4;
  uint8_t subIdLen;
};

extern const uint8_t esp_mac[];
const uint8_t qing_mac[] = {0x4C, 0x65, 0xA8, 0xD4, 0x58, 0x2D, 0x34, 0x00, 0xFF};
extern const uint8_t telink_mac[];

const macMap vendorList[] = {
    {"Esp", esp_mac, 2},
    {"Qing", qing_mac, 1},
    {"Tlnk", telink_mac, 1},
};

uint32_t mac4_hash(const uint8_t* mac4) {
  // while (c = *str++) hash = ((hash << 5) + hash) + c;              /* hash * 33    + c */ -> 2 collosions at Esp
  // while (c = *str++) hash = c + (hash << 6) + (hash << 16) - hash; /* hash * 65599 + c */ -> 3 collosions at Esp
  uint32_t hash = mac4[0];
  hash = ((hash << 5) + hash) + mac4[1];
  hash = ((hash << 5) + hash) + mac4[2];
  hash = ((hash << 5) + hash) + mac4[3];
  //hash = ((hash << 16) + (hash << 6) - hash) + mac4[1];
  //hash = ((hash << 16) + (hash << 6) - hash) + mac4[2];
  //hash = ((hash << 16) + (hash << 6) - hash) + mac4[3];
  return hash;
}

void mac4_hash_str(char* buffer, uint len, const uint8_t* mac4) {
  uint32_t hash = mac4_hash(mac4);
  for (int idx = 0; idx < len; idx++) {
    buffer[idx] = 'A' + (hash % 26);
    hash /= 26;
  }
  buffer[len] = 0;
}

inline bool macCmp(const uint8_t* mac4_, const uint8_t* mac6_) {
  if (mac4_[0] != mac6_[0] || mac4_[1] != mac6_[1] || mac4_[2] != mac6_[2]) return false;
  if ((mac4_[3] & 0x04) != 0 && (mac4_[3] & 0xf0) != (mac6_[3] & 0xf0)) return false;
  return true;
}

void mac_to_strid(char* id_, const uint8_t mac_[8], uint macLen_) {
  const macMap* vendor = nullptr;
  const uint8_t* mac4 = nullptr;
  for (int idx = 0, len = sizeof(vendorList) / sizeof(macMap); idx < len; idx++) {
    vendor = vendorList + idx;
    mac4 = vendor->mac4;
    while (mac4[0] != 0xff && !macCmp(mac4, mac_)) mac4 += 4;
    if (mac4[0] != 0xff) break; // found it
  }
  int idx = 0, pos = 0;
  if (mac4[0] != 0xff) {
    char vendorHash[vendor->subIdLen + 1];
    mac4_hash_str(vendorHash, vendor->subIdLen, mac4);
    pos = sprintf(id_, "%s%s_", vendor->name, vendorHash);
    idx = 3;
  }
  for (; idx < macLen_; idx++) pos += sprintf(id_ + pos, "%02X", mac_[idx]);
}

void mac_to_macid(char* id_, const uint8_t mac_[8], uint macLen_) {
  for (int idx = 0, pos = 0; idx < macLen_; idx++) pos += sprintf(id_ + pos, "%02X", mac_[idx]);
}

void mac_to_strid_integrity_check() {
  STFLOG_INFO("Starting integrity check for mac_to_strid\n");

  uint coll = 0;
  for (int idx = 0, len = sizeof(vendorList) / sizeof(macMap); idx < len; idx++) {
    const macMap* vendor = vendorList + idx;
    const uint8_t* mac4 = vendor->mac4;
    char vendorHash1[vendor->subIdLen + 1];
    char vendorHash2[vendor->subIdLen + 1];
    uint mlen = 0;
    while (mac4[4 * mlen] != 0xff) mlen++;
    STFLOG_INFO("Checking %s with %u element(s).\n", vendor->name, mlen);
    for (uint j = 0; j < mlen - 1; j++) {
      mac4_hash_str(vendorHash1, vendor->subIdLen, &mac4[j * 4]);
      for (uint k = j + 1; k < mlen; k++) {
        mac4_hash_str(vendorHash2, vendor->subIdLen, &mac4[k * 4]);
        if (strcmp(vendorHash1, vendorHash2) == 0) {
          STFLOG_INFO("Collosion at %02X%02X%02X vs %02X%02X%02X -> %s\n", mac4[j * 4], mac4[j * 4 + 1], mac4[j * 4 + 2], mac4[k * 4], mac4[k * 4 + 1], mac4[k * 4 + 2], vendorHash1);
          coll++;
        }
      }
    }
  }
  STFLOG_INFO("Integrity check for mac_to_strid finished with %u collosions.\n", coll);
}

/* clang-format off */
//[01:22:38]Collosion at 9097D5 vs C4DD57 -> QW
//[01:22:38]Collosion at A4CF12 vs F008D1 -> NU
const uint8_t esp_mac[] = {
  0x08, 0x3A, 0xF2, 0x00,
  0x0C, 0xDC, 0x7E, 0x00,
  0x10, 0x52, 0x1C, 0x00,
  0x18, 0xFE, 0x34, 0x00,
  0x1C, 0x9D, 0xC2, 0x00,
  0x24, 0x0A, 0xC4, 0x00,
  0x24, 0x62, 0xAB, 0x00,
  0x24, 0x6F, 0x28, 0x00,
  0x24, 0xA1, 0x60, 0x00,
  0x24, 0xB2, 0xDE, 0x00,
  0x2C, 0x3A, 0xE8, 0x00,
  0x2C, 0xF4, 0x32, 0x00,
  0x30, 0x83, 0x98, 0x00,
  0x30, 0xAE, 0xA4, 0x00,
  0x34, 0x86, 0x5D, 0x00,
  0x34, 0xAB, 0x95, 0x00,
  0x34, 0xB4, 0x72, 0x00,
  0x3C, 0x61, 0x05, 0x00,
  0x3C, 0x71, 0xBF, 0x00,
  0x40, 0xF5, 0x20, 0x00,
  0x44, 0x17, 0x93, 0x00,
  0x48, 0x3F, 0xDA, 0x00,
  0x4C, 0x11, 0xAE, 0x00,
  0x4C, 0x75, 0x25, 0x00,
  0x50, 0x02, 0x91, 0x00,
  0x54, 0x5A, 0xA6, 0x00,
  0x58, 0xBF, 0x25, 0x00,
  0x5C, 0xCF, 0x7F, 0x00,
  0x60, 0x01, 0x94, 0x00,
  0x60, 0x55, 0xF9, 0x00,
  0x68, 0xC6, 0x3A, 0x00,
  0x70, 0x03, 0x9F, 0x00,
  0x78, 0xE3, 0x6D, 0x00,
  0x7C, 0x87, 0xCE, 0x00,
  0x7C, 0x9E, 0xBD, 0x00,
  0x7C, 0xDF, 0xA1, 0x00,
  0x80, 0x7D, 0x3A, 0x00,
  0x84, 0x0D, 0x8E, 0x00,
  0x84, 0xCC, 0xA8, 0x00,
  0x84, 0xF3, 0xEB, 0x00,
  0x84, 0xF7, 0x03, 0x00,
  0x8C, 0xAA, 0xB5, 0x00,
  0x8C, 0xCE, 0x4E, 0x00,
  0x90, 0x97, 0xD5, 0x00,
  0x94, 0x3C, 0xC6, 0x00,
  0x94, 0xB9, 0x7E, 0x00,
  0x98, 0xCD, 0xAC, 0x00,
  0x98, 0xF4, 0xAB, 0x00,
  0x9C, 0x9C, 0x1F, 0x00,
  0xA0, 0x20, 0xA6, 0x00,
  0xA0, 0x76, 0x4E, 0x00,
  0xA4, 0x7B, 0x9D, 0x00,
  0xA4, 0xCF, 0x12, 0x00,
  0xA4, 0xE5, 0x7C, 0x00,
  0xA8, 0x03, 0x2A, 0x00,
  0xA8, 0x48, 0xFA, 0x00,
  0xAC, 0x0B, 0xFB, 0x00,
  0xAC, 0x67, 0xB2, 0x00,
  0xAC, 0xD0, 0x74, 0x00,
  0xB4, 0xE6, 0x2D, 0x00,
  0xB8, 0xF0, 0x09, 0x00,
  0xBC, 0xDD, 0xC2, 0x00,
  0xBC, 0xFF, 0x4D, 0x00,
  0xC4, 0x4F, 0x33, 0x00,
  0xC4, 0x5B, 0xBE, 0x00,
  0xC4, 0xDD, 0x57, 0x01,
  0xC8, 0x2B, 0x96, 0x00,
  0xC8, 0xC9, 0xA3, 0x00,
  0xCC, 0x50, 0xE3, 0x00,
  0xD8, 0xA0, 0x1D, 0x00,
  0xD8, 0xBF, 0xC0, 0x00,
  0xD8, 0xF1, 0x5B, 0x00,
  0xDC, 0x4F, 0x22, 0x00,
  0xE0, 0x98, 0x06, 0x00,
  0xE0, 0xE2, 0xE6, 0x00,
  0xE8, 0x68, 0xE7, 0x00,
  0xE8, 0xDB, 0x84, 0x00,
  0xEC, 0x94, 0xCB, 0x00,
  0xEC, 0xFA, 0xBC, 0x00,
  0xF0, 0x08, 0xD1, 0x01,
  0xF4, 0xCF, 0xA2, 0x00,
  0xFC, 0xF5, 0xC4, 0x00,
  0xFF,
};
const uint8_t telink_mac[] = {
  0x40, 0x62, 0x34, 0x00,
  0x70, 0xB3, 0xD5, 0x04,  // 70:B3:D5:05:80:00/36 is not supported
  0xA4, 0xC1, 0x38, 0x00,
  0xC4, 0x19, 0xD1, 0x00,
  0xD8, 0x0B, 0xCB, 0x00,
  0xD8, 0x5F, 0x77, 0x00,
  0xFF,
};
/* clang-format on */

} // namespace stf
